---
slug: surviving-at-the-bottom-of-the-iceberg
title: Surviving at the bottom of the iceberg
description: Pitfalls of deconstructing monoliths
author: David Simão
author_title: Software Engineer
author_url: https://github.com/madoke
author_image_url: https://avatars.githubusercontent.com/u/185598?s=460&v=4
image: /assets/images/iceberg-a777f4bac14629d69895f3d6f644451c.jpg
tags: [software engineering, legacy, monolith, refactoring]
---

import ImageWithAttribution from "../src/theme/ImageWithAttribution";

Maintenance and evolution of legacy systems is one of the most common challenges faced by software engineers. Every time we produce a line of code and it reaches production, we’re already creating legacy for our future selves or somebody else to look after. If not properly maintained, most systems won’t age well, and therefore most of us will eventually at some point in our careers face a rusty old behemoth that’s important to the business and simply cannot be shut down. Circumstances are different in every company but there are some common pitfalls that usually show up. In this article, I will go through the ones that I’ve come across so far and talk about the solutions used, which may or not be applicable to similar situations.

<!--truncate-->

import IcebergImage from './img/iceberg.jpg'

<ImageWithAttribution
  src={IcebergImage}
  sourceName={'Unsplash'}
  authorName={'Alexander Hafemann'}
  imageName={"Arctic Icebergs in Ilulissat, Greenland"}
  imageUrl={'https://unsplash.com/photos/M-EwSRl8BK8'}/>

## No space left for maintenance

The ‘legacy’ label is just around the corner for any system and can be applied shortly after a new product release. The company has already moved on to the next big project before you even notice, and nobody outside the team will think about maintenance. This is the point where we tend to make mistakes and also forget about maintenance, because the next big thing is now the top priority. You can (and should) build the most resilient and scalable software that this world has seen, but if there isn't a maintenance process in place, chances are that after a while you or someone else will be forcefully remembered of this software's existence because something started to fail. The problem now is that its framework and runtimes are outdated, or your CI/CD has changed and you can no longer operate it like the other services because there’s a big technical debt to clear.
For most systems, this is inevitable and most certainly will happen because a company’s resources in terms of manpower are limited. However, it is definitely possible to mitigate the impacts in the components that that we believe that are core to the business and will be around for a while.
There are two important things to understand here:
- Maintenance is not a feature, so if you really need your system to be reliable and scalable, there is a permanent stream of work that should be kept going in parallel with everything else. The less effort you put into it, the bigger the debt to pay further ahead;
- The responsibility belongs to the whole company, rather than the engineering team alone. I’ve tried to handle maintenance and scalability in the past by “self organizing” the team or overestimating other projects and it didn’t last long because the business would eventually reclaim the time we spent clearing tech debt with more agressive dates or workload. It really needs to be part of the team’s public roadmap, so that everyone understands what’s going on.

As a software engineer, leader or not it is your responsibility to make it very clear to everyone why maintenance is needed and how much will it cost, as well as what are the consequences of not doing it. You will probably need to repeat it more than once because it goes against all that “fail fast” and “time to market” jargon, so people outside engineering will probably be more reluctant to accept trading speed for stability. A good strategy that’s helped me so far is to produce a document with the overall technical strategy and discuss it with everyone that can have an impact on the team's agenda, including the team itself. It shouldn't need to be a sales pitch, make sure that you get input from as much participants as possible so that you can use it later as a guarantee that these people will support you. This document should be made available to everyone, and serves as documentation for the future. If the need is clear and everyone buys in, then you can officially allocate capacity for maintenance and scalability on every system owned by your teams.


## Outdated Technology

> “If you think your software is up to date, just wait a couple of months” - *Myself* (Adapted from Mark Twain’s original: “If you don’t like the weather in New England, just wait a few minutes”)

It’s fairly easy to build stable and long lasting software that can remain untouched and reliable for years in production. However, it's a different story to keep it updated, and it usually cannot be done without proper maintenance.
As you read this article, there are probably people working on improving the JVM internals, a new release of the golang compiler, bugfixes in kubernetes, 15 new JavaScript frameworks, and the list goes on. The tech ecosystem evolves at a much faster pace because there are thousands of people working on it, whereas your app, only depends on you or your team.
Having that said, outdated tech stacks are the most common scenario for legacy software and this is a problem for your team because it will keep on increasing the technical debt and the maintenance overhead. When paired with bad code practices, the mixture is explosive. So what to do ? Refactor or reimplement the whole thing in `<NEW_TRENDY_TECH>` right ? It's tempting to do a File > New Project straight away (I've done it hundreds of times), however things can get quickly out of hand because there is a very high cost associated with redoing something for scratch (Just think about everything that's not the actual code: tests, logs, monitoring, CI/CD, etc). If the system is critical, and you can't operate it, you probably want to invest some time in fixing it first, or at least making it easier to use/get acquainted. There are some popular actions that usually apply to most cases:
- Integrating the existing CI/CD pipeline system for automated builds, testing and deploys. It will speed up the development cycles and reduce confusion if every project shares the same CI/CD infrastructure;
- Using the same runtime and infrastructure as your modern services (E.g: Kubernetes). Like the point above, its easier if there is only one kind of infrastructure to operate;
- Upgrading frameworks and runtimes to the latest LTS version. For keeping the system out of potential security threats, and eventually enable some features that you might need for refactoring later;
- Write documentation for every maintenance process that needs to take place more than once, even if it's just once a year. This will give everybody a way to find out how to operate the system;
If you can clear these, it will lower the maintenance overhead and it creates better conditions for refactoring and reimplementing should the opportunity present itself


## Nobody wants to touch it

As developers, we always prefer to start from scratch, rather than picking up somebody else’s code, even if it’s brilliantly designed. Improving or refactoring an application built ages ago, in a language or technology that’s not sexy anymore is something that won’t naturally motivate young teams, especially if they need to clean up messy code and processes. There are two strategies that helped me motivate my teams so far:
- Always have a visible plan and keep reminding everyone about the end game. Pretty much like the technical roadmap is needed to justify your team’s allocation, you need to establish a mission and a contract with your team, so that those boring and unappealing tasks can be seen as a necessary evil to a greater good
- Include senior developers in the project. More experienced people tend to create less friction and will be able to understand your vision more quickly and help you out spreading it. Don’t forget that we’re all social creatures, and tend to follow good examples.


## Few people to nobody know how to operate it

It is also a very common situation. Devs are always moving between companies, leaving a trail of software behind. Working on something that already exists is far more common than building something new. So if you’ve just inherited a giant whale of code, developed by a team of unknown heroes who left nothing but a couple of empty documentation pages and good luck wishes behind, it’s time to get acquainted with it.
It will take you some time, and it will not be fun but you need to do it before you can actually have a plan. Otherwise you will be changing your plan every time a new variable comes up.
Gather everyone that was involved with the project, do some workshops, ask some questions and start building the documentation that never existed. Some points that might guide you in this quest:
- How do the customers use your application
- What are the core features
- Who else inside the company uses the application and how do they use it
- How is it deployed to production
- How is it tested
- What are the main components and what kind of coupling there is between them

With greater knowledge about the plataform and the application you will be better equipped to build a technical strategy plan that’s more realistic and useful to the business


## The business does not stop

In most companies, software stability and scalability are variables that usually don’t take part in business decisions like closing a new deal, onboarding a new customer or requesting a feature. This can happen for a number of reasons, which typically boil down to internal issues of some sort like strategy or communication. It can be a big source of frustration for everyone, so in order to overcome it, it will sometimes require everyone to be more objective and pragmatic. Bottomline is that people that are selling/using your product will assume that it works and scales seamlessly, which is your responsibility as an engineer to guarantee. The important thing here is to be able to properly identify and understand the business rules and act accordingly. Some useful guidelines that have helped me so far
- Make the platform status visible to everyone at all times
- If the product isn’t released yet and you need time to invest in stability and scalability it is better to do it now
- If the product is already launched you might need to ‘stop the bleeding’ before thinking about adding features or refactoring
- Everything will be a lot smoother if you know the business, the customers, and everyone involved in the operation from sales to infrastructure


## Rebuilding or reimplementing

Reimplementing everything from scratch

Splitting the logic into microservices

Building components on the side


## Final remarks

Get acquainted with the platform

Buy in from the whole company

Always have a plan visible for everybody

Update and modernize before refactoring




